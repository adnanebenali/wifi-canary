/* Wi‑Fi Canary single‑HTML app
 * Expects directory structure:
 *   index.html (this file)
 *   ../../logs/*.ledger.json     ← data per day (existing in your project)
 *   ../../logs/ledger-index.json ← generated by daemon (array of {date, path})
 *   ../../logs/heartbeat.json    ← generated by daemon { ts: ISO-8601 }
 * Falls back to ../../logs/daemon-heartbeat.txt if heartbeat.json not present.
 */
const el = sel => document.querySelector(sel);
const livePill = el('#live-pill');
const notice = el('#notice');
const heatmap = el('#heatmap');

const LOGS_BASE = new URL('../../logs/', window.location);
const logUrl = (p) => new URL(p, LOGS_BASE).toString();



// ===== Added helpers (keep comments) =====
const monthBand = document.getElementById('monthBand');

function parseYMD(s) {
  const m = String(s).match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return null;
  return { y: +m[1], m: +m[2], d: +m[3] };
}
function ymdToDate({ y, m, d }) { return new Date(y, m - 1, d); }
function formatMonthTitle(ym) {
  const dt = ymdToDate({ y: ym.y, m: ym.m, d: 1 });
  return dt.toLocaleString(undefined, { month: 'long', year: 'numeric' });
}
function daysInMonth(y, m) { return new Date(y, m, 0).getDate(); }


async function tintMonthBandPills() {
  const pills = document.querySelectorAll('.month-band .day:not(.disabled)');
  // Remove prior tints
  pills.forEach(p => p.classList.remove('day--red', 'day--orange', 'day--yellow', 'day--green', 'day--gray'));

  // Fetch in parallel but don’t block UI; paint as results arrive
  await Promise.allSettled(Array.from(pills).map(async p => {
    const d = p.dataset.date;
    const tint = await fetchDayTint(d);
    if (!tint) return;
    // Guard if strip re-rendered meanwhile
    if (!document.contains(p)) return;
    p.classList.add(`day--${tint}`);
  }));
}

function renderMonthBand(selectedDateStr) {
  if (!dates.length) { monthBand.innerHTML = ''; return; }

  // Ensure dates are sorted ascending (important for pos navigation)
  // If you're 100% sure already sorted, you can remove this.
  // dates.sort(); // only if safe in your app

  // Clamp selectedDateStr to an actual available date
  if (!dates.includes(selectedDateStr)) {
    selectedDateStr = dates[dates.length - 1]; // latest available
    pos = dates.indexOf(selectedDateStr);
    if (typeof selectDay === 'function') selectDay(selectedDateStr, true);
  } else {
    pos = dates.indexOf(selectedDateStr);
  }

  const ym = parseYMD(selectedDateStr);
  const totalDays = daysInMonth(ym.y, ym.m);

  // Dates in this visible month
  const inThisMonth = dates.filter(d => {
    const p = parseYMD(d);
    return p.y === ym.y && p.m === ym.m;
  });
  const setForMonth = new Set(inThisMonth);

  // --- Day pills (same as you had) ---
  let daysHtml = '';
  for (let d = 1; d <= totalDays; d++) {
    const ds = `${ym.y}-${String(ym.m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
    const enabled = setForMonth.has(ds);
    const cls = ['day', enabled ? '' : 'disabled', (ds === selectedDateStr ? 'current' : '')].filter(Boolean).join(' ');
    daysHtml += `<button class="${cls}" data-date="${ds}" ${enabled ? '' : 'disabled'}>${d}</button>`;
  }

  // --- Month dropdown: ONLY months that exist in dates[] (across years) ---
  const MONTH_NAMES = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

  // Build unique list of available months from dates[], in chronological order
  const monthKeys = [];
  const monthKeySet = new Set();
  for (const d of dates) {
    const p = parseYMD(d);
    const key = `${p.y}-${String(p.m).padStart(2, '0')}`; // YYYY-MM
    if (!monthKeySet.has(key)) {
      monthKeySet.add(key);
      monthKeys.push(key);
    }
  }

  const currentMonthKey = `${ym.y}-${String(ym.m).padStart(2, '0')}`;

  const monthOptions = monthKeys.map(key => {
    const [yy, mm] = key.split('-');
    const y = Number(yy);
    const m = Number(mm);
    const label = `${MONTH_NAMES[m - 1]} ${y}`;
    const selected = (key === currentMonthKey) ? 'selected' : '';
    return `<option value="${key}" ${selected}>${label}</option>`;
  }).join('');

  const monthDropSelector = `
    <label class="mb-dropdown">
      <span class="sr-only">Month</span>
      <select id="monthSelect" aria-label="Select month">
        ${monthOptions}
      </select>
    </label>
  `;

  // --- Prev/Next DAY navigation buttons ---
  const prevDisabled = (pos <= 0) ? 'disabled' : '';
  const nextDisabled = (pos >= dates.length - 1) ? 'disabled' : '';

  const prevBtn = `<button class="mb-nav" data-nav="prevDay" ${prevDisabled}>◀</button>`;
  const nextBtn = `<button class="mb-nav" data-nav="nextDay" ${nextDisabled}>▶</button>`;

  monthBand.innerHTML = `${prevBtn}${monthDropSelector}${daysHtml}${nextBtn}`;

  // Month dropdown change: jump to latest day in that chosen month
  const monthSelect = monthBand.querySelector('#monthSelect');
  if (monthSelect) {
    monthSelect.addEventListener('change', () => {
      const chosenKey = monthSelect.value; // YYYY-MM
      const candidates = dates.filter(d => d.startsWith(chosenKey + '-'));
      if (candidates.length) {
        const target = candidates[candidates.length - 1]; // latest day in that month
        pos = dates.indexOf(target);
        selectDay(target, true);
        renderMonthBand(target);
      }
    });
  }

  // Tint pills (keep your existing hook)
  if (typeof tintMonthBandPills === 'function') tintMonthBandPills();

  // Day pill click -> select
  monthBand.querySelectorAll('.day:not(.disabled)').forEach(btn => {
    btn.addEventListener('click', () => {
      const d = btn.getAttribute('data-date');
      pos = dates.indexOf(d);
      selectDay(d, true);
      renderMonthBand(d);
    });
  });

  // Prev/Next day click
  monthBand.querySelectorAll('.mb-nav').forEach(btn => {
    btn.addEventListener('click', () => {
      const dir = btn.getAttribute('data-nav');
      if (dir === 'prevDay' && pos > 0) {
        const target = dates[pos - 1];
        pos = pos - 1;
        selectDay(target, true);
        renderMonthBand(target);
      } else if (dir === 'nextDay' && pos < dates.length - 1) {
        const target = dates[pos + 1];
        pos = pos + 1;
        selectDay(target, true);
        renderMonthBand(target);
      }
    });
  });
}

function wireDayNavKeyboard() {
  document.addEventListener('keydown', (e) => {
    // Avoid hijacking typing in inputs/selects/textareas
    const t = e.target;
    const tag = (t && t.tagName) ? t.tagName.toLowerCase() : '';
    if (tag === 'input' || tag === 'textarea' || tag === 'select' || t?.isContentEditable) return;

    const key = e.key;

    const goPrev = () => {
      if (pos > 0) {
        const target = dates[pos - 1];
        pos--;
        selectDay(target, true);
        renderMonthBand(target);
      }
    };

    const goNext = () => {
      if (pos < dates.length - 1) {
        const target = dates[pos + 1];
        pos++;
        selectDay(target, true);
        renderMonthBand(target);
      }
    };

    // < and > plus arrow keys
    if (key === '<' || key === ',' || key === 'ArrowLeft') {
      // Note: key === ',' catches non-shift comma. If you ONLY want '<', remove ','.
      e.preventDefault();
      goPrev();
    } else if (key === '>' || key === '.' || key === 'ArrowRight') {
      // Same note: '.' is non-shift dot; remove if you only want '>'.
      e.preventDefault();
      goNext();
    }
  });
}

function currentLocalHHMM() {
  const now = new Date();
  return { hh: now.getHours(), mm: now.getMinutes() };
}


function statusColor(s) {
  s = String(s || '').toLowerCase();
  if (s === 'greener') return '#6AB572'; //'#85E3AE'; //'#1fb86a'; //'#2bd67b';
  if (s === 'green') return '#437348'; //'#57945D'; //'#437348';
  //if (s==='yellowish')	return '#A2AD54';
  if (s === 'yellow') return '#EAC75D';
  if (s === 'orange') return '#FF7F27';
  if (s === 'red') return '#ED1C24';
  if (s === 'gray' || s === 'grey') return '#495a84';
  return '#6da3ff';
}


let index = [];           // [{date, path}...]
let dates = [];           // ["2025-11-06", ...]
let pos = -1;             // current index in dates[]
let liveTimer = null;     // polling handle when viewing "today"

const sleep = (ms) => new Promise(r => setTimeout(r, ms));

async function fetchJson(url) {
  const r = await fetch(url + (url.includes('?') ? '&' : '?') + 't=' + Date.now());
  if (!r.ok) throw new Error(`${url} → ${r.status}`);
  return r.json();
}
async function fetchText(url) {
  const r = await fetch(url + (url.includes('?') ? '&' : '?') + 't=' + Date.now());
  if (!r.ok) throw new Error(`${url} → ${r.status}`);
  return r.text();
}
function isRecentHeartbeat(iso, horizonSec = 45) {
  try {
    const ts = new Date(iso).getTime();
    return (Date.now() - ts) <= horizonSec * 1000;
  } catch { return false; }
}

async function loadIndex() {
  try {
    index = await fetchJson(logUrl('ledger-index.json'));
    if (!Array.isArray(index)) throw new Error('ledger-index.json is not an array');
  } catch (e) {
    console.error('Failed to load ledger-index.json', e);
    showNotice(`Could not load <code>` + logUrl('ledger-index.json') + `</code>. Make sure the daemon generates it.`, 'err');
    index = [];
  }
  dates = index.map(x => x.date).sort();
  if (dates.length) {
    // Default to the last date (today or latest available)
    pos = dates.length - 1;
    await selectDay(dates[pos], /*userInitiated*/false);
    renderMonthBand(dates[pos]);
  } else {
    renderEmpty();
  }

  wireDayNavKeyboard();
}

async function selectDay(date, userInitiated) {

  hideNotice();
  stopLivePoll();

  const entry = index.find(x => x.date === date);
  if (!entry) {
    showNotice(`No ledger entry for <b>${date}</b>.`, 'warn');
    renderEmpty();
    return;
  }

  const entryPath = entry.path;   // ✅ ADD THIS

  try {
    const ledger = await fetchJson(logUrl(entryPath));   // ✅ uses entryPath
    renderLedger(ledger, date);
  } catch (e) {
    console.error('Failed to load ledger', e);
    showNotice(`Could not load <code>${logUrl(entryPath)}</code>.`, 'err');
    renderEmpty();
    return;
  }

  const isLatest = (date === dates[dates.length - 1]);
  if (isLatest) startLivePoll(date);
}


function showNotice(html, kind = 'warn') {
  notice.hidden = false;
  notice.innerHTML = `<span class="badge ${kind}">${kind.toUpperCase()}</span> ` + html;
}
function hideNotice() { notice.hidden = true; notice.innerHTML = ''; }

function renderEmpty() {
  heatmap.innerHTML = `<div class="card">
    <h3>No data</h3>
    <div class="small">Waiting for ledgers…</div>
  </div>`;
}

function safe(x, d = '—') { return (x === undefined || x === null || x === '') ? d : x; }

function escAttr(value) {
  if (value == null) return '';
  return String(value)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;');
}


// Shared color→label mapping used by both legend and tooltips
const STATUS_LABELS = {
  greener: 'Excellent',
  green: 'Good',
  yellow: 'Fair or Degrading..',
  orange: 'Degraded',
  red: 'Bad!',
  grey: 'Not enough data',
};

// Quick lookup helper
function GetStatusLabel(key) {
  if (!key) return key;
  const norm = String(key).toLowerCase();
  return STATUS_LABELS[norm] ?? key; // fallback to raw if unknown
}


// -------------- MONTH BAND DAILY NAVIGATION --------------

// Cache so we don't refetch when hopping months
const dayStatusCache = new Map(); // key: 'YYYY-MM-DD' -> 'red'|'orange'|'yellow'|'green'|'gray'

function normalizeStatus(s) {
  if (!s) return null;
  const x = String(s).toLowerCase();
  if (x.includes('red')) return 'red';
  if (x.includes('orange')) return 'orange';
  //if (x.includes('yellowish')) return 'yellowish';
  if (x.includes('yellow')) return 'yellow';
  if (x.startsWith('green')) return 'green';     // matches green / greener
  return null;
}

// Decide day tint from per-minute ledger (array form)
function computeDayTintFromArray(ledgerArray) {
  let hasRed = false, hasOrange = false, hasYellow = false, hasGreen = false;
  let reds = 0, oranges = 0, yellows = 0;
  let evaluatedCount = 0;

  for (const row of ledgerArray) {
    const st = normalizeStatus(row?.Status ?? row?.status);
    if (!st) continue;
    evaluated = true;
    evaluatedCount += 1;
    if (st === 'red') {
      reds += 1;
      hasRed = (reds > 5) ? true : false;
    }
    else if (st === 'orange') {
      oranges += 1;
      hasOrange = (oranges > 5) ? true : false;
    }
    else if (st === 'yellow') {
      yellows += 1;
      hasYellow = (yellows > 5) ? true : false;
    }
    else if (st === 'green') {
      hasGreen = true;
    }

    if (hasRed) break; // worst possible
  }
  if (!evaluated) return 'gray';
  if (hasRed) return 'red';
  if (hasOrange) return 'orange';
  if (hasYellow) return 'yellow';
  if (hasGreen) return 'green';
  return 'gray';
}

async function fetchDayTint(dateStr) {
  if (dayStatusCache.has(dateStr)) return dayStatusCache.get(dateStr);
  try {
    const resp = await fetch(logUrl(`${dateStr}.ledger.json`), { cache: 'no-store' });
    if (!resp.ok) { dayStatusCache.set(dateStr, null); return null; }
    const data = await resp.json();
    let tint = null;
    if (Array.isArray(data)) {
      tint = computeDayTintFromArray(data);
    } else if (Array.isArray(data?.minutes) || Array.isArray(data?.cells)) {
      // (optional) support alternate shapes if you ever emit them
      tint = computeDayTintFromArray(data.minutes || data.cells.flat().filter(Boolean));
    }
    dayStatusCache.set(dateStr, tint);
    return tint;
  } catch { dayStatusCache.set(dateStr, null); return null; }
}



/** Render a generic summary table from a ledger JSON.
 * We don't assume strict schema; we try to display sensible aggregates.
 * Expected common fields (if present): totals, devices, hours, cells, etc.
 */
function renderLedger(ledger, date) {
  heatmap.innerHTML = '';

  // -------------------------
  // ARRAY-LEDGER BRANCH (per-minute rows)
  // -------------------------
  if (Array.isArray(ledger)) {
    // Build a 24x60 grid of rows for this day
    const grid = Array.from({ length: 24 }, () => Array(60).fill(null));
    let seen = 0;
    for (const row of ledger) {
      const m = String(row.Minute || row.minute || '').match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}):(\d{2})/);
      if (!m) continue;
      const hh = parseInt(m[2], 10), mm = parseInt(m[3], 10);
      if (hh >= 0 && hh < 24 && mm >= 0 && mm < 60) {
        grid[hh][mm] = row; seen++;
      }
    }

    const bssidSet = new Set();
    const bssidStats = new Map();  // key: bssid → { sumSig, sumRssi, countSig, countRssi }


    // Minute header 1..60
    // Minute header 1..60 (aligns with rows)
    const minuteHeader = (() => {
      let cols = '';
      for (let m = 0; m < 60; m++) cols += `<div class="mincell">${m + 1}</div>`;
      return `
    <div class="minute-header">
      <div class="label"> </div>
      <div class="mins">${cols}</div>
      <div class="rollup-head">Roll-up</div>
    </div>`;
    })();


    // Status legend (uses statusColor for swatches)
    const legend = (() => {
      const items = Object.entries(STATUS_LABELS);
      const parts = items.map(([key, label]) => `
    <span style="display:inline-flex;align-items:center;gap:6px">
      <i style="width:12px;height:12px;border-radius:3px;display:inline-block;background:${statusColor(key)};border:1px solid var(--border)"></i>
      ${label}
    </span>
  `).join('');
      return `<div class="small" style="display:flex;gap:10px;align-items:center;margin:0 0 8px 0">Status: ${parts}</div>`;
    })();


    const now = currentLocalHHMM();
    const isLatestDay = (date === dates[dates.length - 1]);

    // Build one row per hour: hour label + roll-up + 60 minute cells
    const hoursHtml = grid.map((mins, h) => {
      // roll-up
      let seenCount = 0, evalCount = 0, good = 0, bad = 0;
      let hasRed = false, hasOrange = false, hasYellow = false;

      for (let m = 0; m < 60; m++) {
        const r = mins[m];
        if (r) seenCount++;
        const st = r && (r.Status || r.status);
        if (st && !st.includes('grey')) {
          evalCount++;
          const sl = String(st).toLowerCase();
          if (sl.startsWith('green')) good++;
          if (sl.includes('yellow') || sl.includes('orange') || sl.includes('red')) {
            bad++;
            if (sl.includes('red')) {
              hasRed = true;
            }
            else if (sl.includes('orange')) {
              hasOrange = true;
            }
            else {
              hasYellow = true;
            }
          }
        }

      }

      const goodPct = evalCount ? Math.round(100 * good / evalCount) : 0;
      const goodPctIfZero = goodPct == 0 ? 'zero' : '';
      const badPct = evalCount ? Math.round(100 * bad / evalCount) : 0;
      //const badClass = hasRed ? 'red' : (badPct > 0 ? 'orange' : '');
      const badClass = hasRed ? 'red' : (badPct > 0 ? (hasOrange ? 'orange' : 'yellow') : '');

      // if no minutes seen/evaluated, hide rollup entirely
      const hideRollup = (seenCount === 0 && evalCount === 0);

      // 60 minute cells
      const cells = mins.map((row, m) => {

        const med = row ? (row.MedianMs ?? row.median ?? null) : null;
        const sig = row ? (row.MinSig ?? null) : null;
        const samples = row ? (row.Samples ?? row.samples ?? 0) : 0;

        let status = (row && (row.Status || row.status)) || null;

        // If no latency or 0ms or no samples → treat as “not enough data”
        if (!med || med === 0 || !samples) {
          if (!sig || sig == 0) {
            status = 'grey';
          }
        }

        const bssid = row ? (row.Bssid ?? row.BSSID ?? null) : null;
        const didRoam = !!(row && (row.Roaming ?? row.roaming));
        const roamed = didRoam ? ' (Roamed)' : null;

        // pull Rssi from ledger row (could be null on older days)
        const rssi = row ? (row.Rssi ?? row.rssi ?? null) : null;

        if (bssid) {
          bssidSet.add(String(bssid));   // <-- track unique BSSID
        }

        if (bssid != null) {
          const key = String(bssid);
          const stat = bssidStats.get(key) || {
            sumSig: 0,
            sumRssi: 0,
            countSig: 0,
            countRssi: 0,
          };

          if (sig != null && sig !== 0) {
            stat.sumSig += Number(sig);
            stat.countSig += 1;
          }

          if (rssi != null && rssi !== 0) {
            stat.sumRssi += Number(rssi);
            stat.countRssi += 1;
          }

          bssidStats.set(key, stat);
        }


        const statusLabel = status ? GetStatusLabel(status) : null;
        const tipParts = [
          `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`,
          row ? `samples=${row.Samples ?? row.samples ?? '—'}` : null,
          row ? `latency=${row.MedianMs ?? row.median ?? '—'}ms` : null,
          row ? `loss=${row.WorstLoss ?? '—'}%` : null,
          row ? `signal=${row.MinSig ?? '—'}%` : null,
          row ? `rssi=${row.Rssi ?? '—'} dBm` : null,
          row ? `bssid=${bssid ?? '—'} ${roamed ?? ''}` : null,
          row ? `status=${statusLabel ?? status ?? '—'}` : null,
        ].filter(Boolean);
        const tip = tipParts.join('&nbsp;  .  &nbsp;');
        const bg = status ? statusColor(status) : 'transparent';
        const border = status ? '1px solid var(--border)' : '1px solid #2a3b67';
        const nextup = (isLatestDay && h === now.hh && m === (now.mm + 1)) ? ' nextup' : '';

        // show a small center glyph when roaming
        const roamAttr = didRoam ? ' data-roam="1"' : '';
        const roamHtml = didRoam ? '<span class="roam" aria-hidden="true">✦</span>' : '';
        const bssidAttr = bssid ? ` data-bssid="${escAttr(bssid)}"` : '';

        return `<div class="min tip${nextup}"${roamAttr}${bssidAttr} data-tip="${tip}" style="--bg:${bg};--bd:${border}">${roamHtml}</div>`;


      }).join('');

      return `
		  <div class="row">
			<div class="small" style="width:36px;text-align:right;color:var(--muted)">${String(h).padStart(2, '0')}:00</div>
			<div class="gridline">${cells}</div>
			${hideRollup ? '' : `
			  <div class="rollup">
				<div class="chip" title="Minutes seen">${seenCount}</div>
				<div class="chip" title="Minutes evaluated">${evalCount}</div>
				<div class="chip" title="% Good"><span class="badge badge--good${goodPctIfZero}">${goodPct}%</span></div>
				<div class="chip" title="% Bad"><span class="badge badge--bad ${badClass}">${badPct}%</span></div>
			  </div>`}
		  </div>`;

    }).join(''); // ← exactly one join for the map

    const bssidList = Array.from(bssidSet).sort();

    const bssidBadgesHtml = bssidList.length
      ? bssidList.map(b => {
        const stat = bssidStats.get(String(b));

        const avgSig = stat && stat.countSig
          ? Math.round(stat.sumSig / stat.countSig)
          : null;

        const avgRssi = stat && stat.countRssi
          ? Math.round(stat.sumRssi / stat.countRssi)
          : null;

        const sigLabel = (avgSig != null ? `${avgSig}%` : '—');
        const rssiLabel = (avgRssi != null ? `${avgRssi} dBm` : '—');

        const sampleCount =
          stat ? Math.max(stat.countSig || 0, stat.countRssi || 0) : 0;

        // optional title for hover
        const title = sampleCount
          ? `Avg signal ${sigLabel}, avg Rssi ${rssiLabel} over ${sampleCount} minute(s)`
          : 'No samples recorded';

        // simple qualitative band based on signal % (as before)
        let level = '';
        if (avgSig != null) {
          if (avgSig >= 70) level = 'good';
          else if (avgSig >= 40) level = 'med';
          else level = 'low';
        }

        return `
        <button
          class="bssid-badge"
          data-bssid="${escAttr(b)}"
          title="${escAttr(title)}"
        >
          <span class="bssid-badge-main">${b}</span>
          <span class="bssid-badge-main">${sampleCount}</span>
          <span class="bssid-badge-signal bssid-badge-signal--${level}">
            ${sigLabel}
          </span>
          <span class="bssid-badge-signal bssid-badge-signal--${level}">
            ${rssiLabel}
          </span>
        </button>
      `;
      }).join('')
      : `<div class="small bssid-empty">No BSSID data yet.</div>`;



    const heatmapBodyHtml = `
      <div class="heatmap-body">
        <div class="heatmap-hours">
          ${hoursHtml}
        </div>
        <aside class="bssid-panel">
          <div class="bssid-panel-title small">BSSID seen this day</div>
          <div class="bssid-badges">
            ${bssidBadgesHtml}
          </div>
        </aside>
      </div>
    `;


    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
      <h3>Heatmap — ${date}</h3>
      ${legend}
      ${minuteHeader}
      ${heatmapBodyHtml}
      <div class="small" style="margin-top:8px">
        Each cell = one minute. Colors from <code>Status</code>. Hover for details.
        Hover a BSSID badge to isolate its minutes.
      </div>
    `;
    heatmap.appendChild(card);



    // BSSID list
    // Hover over BSSID badge → dim all other minutes,
    // highlight only minutes with that BSSID.
    if (bssidList.length) {
      const badges = card.querySelectorAll('.bssid-badge');
      const minCells = card.querySelectorAll('.min');

      badges.forEach(badge => {
        const bssid = badge.dataset.bssid;

        badge.addEventListener('mouseenter', () => {
          minCells.forEach(cell => {
            const cellBssid = cell.getAttribute('data-bssid');
            if (cellBssid && cellBssid === bssid) {
              cell.classList.add('min--highlight');
              cell.classList.remove('min--dim');
            } else {
              cell.classList.add('min--dim');
              cell.classList.remove('min--highlight');
            }
          });
        });

        badge.addEventListener('mouseleave', () => {
          minCells.forEach(cell => {
            cell.classList.remove('min--dim', 'min--highlight');
          });
        });
      });
    }




    // Summary from grid/ledger
    const minutesSeen = grid.flat().filter(Boolean).length;
    const greens = ledger.filter(r => String(r.Status || '').toLowerCase().startsWith('green')).length;
    const reds = ledger.filter(r => String(r.Status || '').toLowerCase().includes('red')).length;
    const yell = ledger.filter(r => String(r.Status || '').toLowerCase().startsWith('yellow')).length;

    const sum = document.createElement('div');
    sum.className = 'card';
    sum.innerHTML = `
      <h3>Summary — ${date}</h3>
      <table class="table">
        <tr><th>Minutes seen</th><td>${minutesSeen}</td></tr>
        <tr><th>Green-ish</th><td>${greens}</td></tr>
        <tr><th>Yellow-ish</th><td>${yell}</td></tr>
        <tr><th>Red</th><td>${reds}</td></tr>
      </table>
    `;
    heatmap.appendChild(sum);

    return; // END array-ledger branch
  }

  // -------------------------
  // OBJECT-LEDGER BRANCH (fallback, legacy)
  // -------------------------
  const totals = ledger.totals || ledger.summary || {};
  const deviceCount = totals.devices ?? (ledger.devices?.length ?? ledger.deviceCount ?? undefined);
  const pingCount = totals.pings ?? ledger.pingCount ?? undefined;
  const upPct = totals.uptimePct ?? totals.upPct ?? undefined;

  const top = document.createElement('div');
  top.className = 'card';
  top.innerHTML = `
    <h3>Summary — ${date}</h3>
    <table class="table">
      <tr><th>Devices</th><td>${safe(deviceCount)}</td></tr>
      <tr><th>Total pings</th><td>${safe(pingCount)}</td></tr>
      <tr><th>Uptime</th><td>${safe(upPct)}</td></tr>
    </table>
    <div class="small">Rendering from <code>${LOGS_BASE}${date}.ledger.json</code></div>
  `;

  let gridHtml = '';
  if (Array.isArray(ledger.cells)) {
    const rows = ledger.cells.length;
    const cols = Math.max(...ledger.cells.map(r => Array.isArray(r) ? r.length : 0), 0);
    gridHtml = `<div class="card"><h3>Heatmap</h3>
      <div style="display:grid;grid-template-columns:repeat(${cols},minmax(6px,16px));gap:2px">
        ${ledger.cells.map(row => Array.isArray(row) ? row.map(val => {
      const v = Number(val) || 0;
      const a = Math.max(0, Math.min(1, v));
      const hue = Math.round(140 * a);
      return `<div title="${v}" style="width:12px;height:12px;border-radius:2px;background:hsl(${60 + hue} 90% ${20 + 55 * a}%);"></div>`;
    }).join('') : '').join('')}
      </div>
    </div>`;
  }

  let devTable = '';
  if (Array.isArray(ledger.devices)) {
    const rows = ledger.devices.slice(0, 100).map(d => `<tr>
      <td>${safe(d.id || d.mac || d.name)}</td>
      <td>${safe(d.status || d.state)}</td>
      <td>${safe(d.uptimePct ?? d.uptime)}</td>
    </tr>`).join('');
    devTable = `<div class="card">
      <h3>Devices <span class="small">(showing up to 100)</span></h3>
      <table class="table"><thead><tr><th>Device</th><th>Status</th><th>Uptime</th></tr></thead>
      <tbody>${rows || '<tr><td colspan="3" class="small">No device list in ledger.</td></tr>'}</tbody></table>
    </div>`;
  }

  heatmap.appendChild(top);
  if (gridHtml) heatmap.insertAdjacentHTML('beforeend', gridHtml);
  if (devTable) heatmap.insertAdjacentHTML('beforeend', devTable);
}



function setLivePill(isLive) {
  // Always show pill; switch state
  livePill.hidden = false;

  if (isLive) {
    livePill.textContent = 'LIVE';
    livePill.classList.add('live');
    livePill.classList.remove('offline');
  } else {
    livePill.textContent = 'OFFLINE';
    livePill.classList.add('offline');
    livePill.classList.remove('live');
  }
}

// Accept either a pure ISO string, or "ISO alive"
function parseHeartbeatTs(s) {
  if (!s) return null;
  const firstToken = String(s).trim().split(/\s+/)[0]; // take the ISO part
  // Basic sanity: ISO-ish
  if (!/^\d{4}-\d{2}-\d{2}T/.test(firstToken)) return null;
  return firstToken;
}

async function startLivePoll(date) {
  async function pollOnce() {
    let live = false;

    // Prefer JSON heartbeat
    try {
      const hb = await fetchJson(logUrl('heartbeat.json'));
      const ts = parseHeartbeatTs(hb?.ts);
      live = ts ? isRecentHeartbeat(ts, 60) : false; // 60s horizon reduces flicker
    } catch {
      // Fall back to txt heartbeat
      try {
        const txt = await fetchText(logUrl('daemon-heartbeat.txt'));
        const lastLine = txt.trim().split(/\r?\n/).pop();
        const ts = parseHeartbeatTs(lastLine);
        live = ts ? isRecentHeartbeat(ts, 60) : false;
      } catch {
        live = false;
      }
    }

    setLivePill(live);

    // Refresh today's ledger
    const entry = index.find(x => x.date === date);
    if (entry) {
      try {
        const ledger = await fetchJson(logUrl(entry.path));
        renderLedger(ledger, date);
      } catch { /* keep previous render */ }
    }
  }

  await pollOnce();
  liveTimer = setInterval(pollOnce, 15000);
}

function stopLivePoll() {
  if (liveTimer) { clearInterval(liveTimer); liveTimer = null; }
  // Don’t hide: show OFFLINE when you navigate away or stop polling
  setLivePill(false);
}


window.addEventListener('DOMContentLoaded', loadIndex);
